// <copyright file="EncryptPII.cs" company="">
// Copyright (c) 2019 All Rights Reserved
// </copyright>
// <author></author>
// <date>1/22/2019 4:43:43 PM</date>
// <summary>Implements the EncryptPII Plugin.</summary>
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.1
// </auto-generated>

using System;
using System.ServiceModel;
using DeBeers.Common.Utils;
using Microsoft.Xrm.Sdk;
using Microsoft.Xrm.Sdk.Query;

namespace DeBeers.CRM.Plugins
{
    /// <summary>
    /// EncryptPII Plugin.
    /// </summary>    
    public class PIIEncryption: PluginBase
    {
        private string encryptionKey;

        private const int PreOperation = 20;
        private const int PostOperation = 40;
        private const string MayDecrypt = "MayDecrypt";

        /// <summary>
        /// Initializes a new instance of the <see cref="PIIEncryption"/> class.
        /// </summary>
        /// <param name="unsecure">Contains public (unsecured) configuration information.</param>
        /// <param name="secure">Contains non-public (secured) configuration information. 
        /// When using Microsoft Dynamics 365 for Outlook with Offline Access, 
        /// the secure string is not passed to a plug-in that executes while the client is offline.</param>
        public PIIEncryption(string unsecure, string secure)
            : base(typeof(PIIEncryption))
        {
            encryptionKey = secure;
        }


        /// <summary>
        /// Main entry point for the business logic that the plug-in is to execute.
        /// </summary>
        /// <param name="localContext">The <see cref="LocalPluginContext"/> which contains the
        /// <see cref="IPluginExecutionContext"/>,
        /// <see cref="IOrganizationService"/>
        /// and <see cref="ITracingService"/>
        /// </param>
        /// <remarks>
        /// This plugin can run to either encrypt or decrypt data.
        /// It also needs to modify the Column sets to ensure that it has the encrypted values to work on when decrypting.
        /// Following steps required:
        /// - Stage 20 (Pre operation) create and update messages intercepted to encrypt any fields that require encryption.
        /// - Stage 20 (pre operation) retrieve and retrievemultiple messages intercepted to ensure that the "Columnset" parameter includes encrypted columns.
        /// - Stage 40 (post operation) on retrieve and retrievemultiple to decrypt any encrypted fields (subject to the current user having required security role)
        /// </remarks>
        protected override void ExecuteCrmPlugin(LocalPluginContext localContext)
        {
            Action<string> trace = (s) => localContext.Trace(s);
            trace("Start Processing PII Encryption");
            if (localContext == null)
            {
                throw new InvalidPluginExecutionException("localContext");
            }

            // Determine if this is a Create or Retrieve message
            var context = localContext.PluginExecutionContext;
            if (context == null)
            {
                trace("PluginExecutionContext not set");
            }
            else
            {
                var message = context.MessageName;
                var stage = localContext.PluginExecutionContext.Stage;
                trace($"Process PII Encryption for {message} stage {stage}");
                if (message == "Create" || message == "Update")
                {
                    EncryptPII(context, localContext.PluginExecutionContext.Stage, trace);
                }

                if (message == "Retrieve" || message == "RetrieveMultiple")
                {
                    if (stage == PreOperation)
                    {
                        AddEncryptedColsToRetreivedCols(localContext, trace);
                    }
                    else
                    if (stage == PostOperation)
                    {
                        DecryptPII(localContext, stage, trace);
                    }
                    else
                    {
                        trace($"PIIEncryption plugin called unexpectedly for stage {stage}");
                    }
                }
            }
        }


        private void EncryptPII(IPluginExecutionContext context, int stage, Action<string> trace)
        {
            if (!context.InputParameters.ContainsKey("Target"))
            {
                trace("PluginExecutionContext does not contain Target");
            }
            else
            {
                var target = (Entity) context.InputParameters["Target"];
                Entity preImage = null;
                if (context.PreEntityImages.ContainsKey("PreImage")) preImage = context.PreEntityImages["PreImage"];
                var PIIProcessing = new PIIProcessing(encryptionKey);

                trace($"Message: {context.MessageName} Entity: {context.PrimaryEntityName}");
                if ((context.MessageName == "Create" || context.MessageName == "Update") &&
                    stage  == PreOperation)
                {
                    PIIProcessing.EncryptEntity(target, preImage, trace);
                }
                else 
                {
                    trace($"Ignore this message: {context.MessageName} stage: {stage}");
                }
            }
        }

        /// <summary>
        /// Ensure that we are also retrieving the encrypted columns (for decryption during post-operation phase)
        /// Note that Retrieve and RetrieveMultiple have different approaches to specifying the columnset.
        /// Retrieve has a "ColumnSet" parameter in the InputParameters collection.
        /// RetrieveMultiple has a "Query" parameter in the Input Parameters collection - this is a QueryExpression and the column set is elsewhere.
        /// Also avoid adding the extra columns if the user does not have privilege to decrypt - and store MayDecrypt setting in a shared Variable.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="trace"></param>
        private void AddEncryptedColsToRetreivedCols(LocalPluginContext context, Action<string> trace)
        {
            var PIIProcessing = new PIIProcessing(encryptionKey);
            var pluginContext = context.PluginExecutionContext;
            if (PIIProcessing.MayDecrypt(pluginContext.UserId, context.OrganizationService, trace))
            {               
                pluginContext.SharedVariables.Add(MayDecrypt, true);
                if (pluginContext.MessageName == "Retrieve")
                {
                    UpdateColumnSet(pluginContext, PIIProcessing, trace);
                }
                else
                {
                    UpdateColumnSetInQuery(pluginContext, PIIProcessing, trace);
                }
            }
            else
            {
                pluginContext.SharedVariables.Add(MayDecrypt, false);
            }
        }

        /// <summary>
        ///  Update the column set parameter directly.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="trace"></param>
        private void UpdateColumnSet(IPluginExecutionContext context,  PIIProcessing PIIProcessing, Action<string> trace)
        {
            if (!context.InputParameters.ContainsKey("ColumnSet") ||
                !context.InputParameters.ContainsKey("Target"))
            {
                trace("Input parameters for Retrieve does not contain ColumnSet or Target");
            }
            else
            {
                var colSet = (ColumnSet) context.InputParameters["ColumnSet"];
                var target = (EntityReference) context.InputParameters["Target"];
                trace("Adding encrypted columns to columnSet");
                PIIProcessing.AddAdditionalColumns(target, colSet, trace);
            }
        }

        // Update the column set in the associated query.
        private void UpdateColumnSetInQuery(IPluginExecutionContext context,  PIIProcessing PIIProcessing, Action<string> trace)
        {
            if (! (context.InputParameters.ContainsKey("Query") && context.InputParameters["Query"] is QueryExpression ))
            {
                trace("Input parameters for RetrieveMultiple does not contain Query or is not QueryExpression");
            }
            else
            {
                var query = (QueryExpression) context.InputParameters["Query"];
                var colSet = query.ColumnSet;
                var target = new EntityReference(query.EntityName, Guid.Empty);

                trace("Adding encrypted columns to query columnSet");
                PIIProcessing.AddAdditionalColumns(target, colSet, trace);
            }
        }


        private void DecryptPII(LocalPluginContext localContext, int stage, Action<string> trace)
        {
            var context = localContext.PluginExecutionContext;
            if (context.SharedVariables.ContainsKey(MayDecrypt) && (bool) context.SharedVariables[MayDecrypt])
            {
                if (context.MessageName == "Retrieve")
                {
                    DecryptPIIForSingleEntity(localContext, stage, trace, context);
                }
                else if (context.MessageName == "RetrieveMultiple")
                {
                    DecryptPIIForEntityCollection(localContext, stage, trace, context);

                }
            }
        }

        private void DecryptPIIForEntityCollection(LocalPluginContext localContext, int stage, Action<string> trace,
            IPluginExecutionContext context)
        {
            if (!context.OutputParameters.ContainsKey("BusinessEntityCollection"))
            {
                trace("PluginExecutionContext does not contain BusinessEntityCollection in OutputParameters");
            }
            else
            {
                var targets = (EntityCollection) context.OutputParameters["BusinessEntityCollection"];
                var PIIProcessing = new PIIProcessing(encryptionKey);

                if (stage == PostOperation)
                {
                    foreach (var target in targets.Entities)
                    {
                        PIIProcessing.DecryptEntity(target, trace);
                    }
                }
            }
        }

        private void DecryptPIIForSingleEntity(LocalPluginContext localContext, int stage, Action<string> trace,
            IPluginExecutionContext context)
        {
            if (!context.OutputParameters.ContainsKey("BusinessEntity"))
            {
                trace("PluginExecutionContext does not contain BusinessEntity in OutputParameters");
            }
            else
            {
                var target = (Entity) context.OutputParameters["BusinessEntity"];
                var PIIProcessing = new PIIProcessing(encryptionKey);

                if (stage == PostOperation)
                {
                    PIIProcessing.DecryptEntity(target, trace);
                }
            }
        }
    }
}
